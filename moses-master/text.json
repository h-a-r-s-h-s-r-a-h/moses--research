{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Simple Neural Network Model for Molecular Property Prediction\n",
        "\n",
        "This notebook demonstrates a simple neural network model for predicting molecular properties."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Import libraries\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "from rdkit import Chem\n",
        "from rdkit.Chem import Descriptors, AllChem\n",
        "from sklearn.model_selection import train_test_split\n",
        "from sklearn.preprocessing import StandardScaler\n",
        "from sklearn.metrics import mean_squared_error, r2_score\n",
        "from tensorflow import keras\n",
        "from tensorflow.keras import layers\n",
        "\n",
        "# Set visualization styles\n",
        "plt.style.use('seaborn-v0_8-darkgrid')\n",
        "%matplotlib inline"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 1. Import Dataset\n",
        "\n",
        "Let's try to import the MOSES dataset. If it's not available, we'll create a sample dataset."
      ]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Try to import the MOSES dataset\n",
        "try:\n",
        "    # First, check if we need to run git lfs pull\n",
        "    import subprocess\n",
        "    subprocess.run(['git', 'lfs', 'pull'], check=False)\n",
        "    \n",
        "    # Try to load the dataset\n",
        "    df = pd.read_csv('data/train.csv')\n",
        "    print(f\"MOSES dataset loaded with shape: {df.shape}\")\n",
        "except Exception as e:\n",
        "    print(f\"Error loading MOSES dataset: {e}\")\n",
        "    print(\"Creating a sample dataset for demonstration...\")\n",
        "    \n",
        "    # Create a sample dataset with diverse molecules\n",
        "    sample_smiles = [\n",
        "        'CCO', 'CC(=O)O', 'c1ccccc1', 'CCN', 'c1ccccc1Cl', 'CC(C)CC',\n",
        "        'CCOC(=O)C', 'c1ccccc1N', 'CCCBr', 'CC(C)(C)C', 'CCOCC', 'CCNCC',\n",
        "        'COC(=O)C', 'CC#N', 'CNC(=O)C', 'CC(=O)NC', 'CN=C=O', 'c1cc(O)ccc1',\n",
        "        'CC(C)=O', 'CCS', 'CCC(=O)O', 'CC(C)O', 'CCCC', 'c1cnc[nH]1',\n",
        "        'c1ccc2ccccc2c1', 'CS(=O)(=O)C', 'CC1CCCCC1', 'C1CCNCC1',\n",
        "        'c1ccc(F)cc1', 'c1cc(Cl)c(Cl)cc1', 'c1cc(O)c(O)cc1', 'CCC(N)C(=O)O',\n",
        "        'CC(C)c1ccccc1', 'CC(=O)c1ccccc1', 'c1cccs1', 'c1ccncc1',\n",
        "        'c1cc(C(=O)O)ccc1', 'CNC', 'c1cc(N)ccc1', 'C1CCCCC1'\n",
        "    ]\n",
        "    \n",
        "    # Generate target properties (simulated)\n",
        "    np.random.seed(42)\n",
        "    boiling_points = np.random.normal(100, 50, len(sample_smiles)) \n",
        "    # Adjust based on molecular complexity\n",
        "    for i, smiles in enumerate(sample_smiles):\n",
        "        mol = Chem.MolFromSmiles(smiles)\n",
        "        if mol is not None:\n",
        "            # Simple complexity heuristic: heavier and more complex molecules have higher boiling points\n",
        "            weight = Descriptors.MolWt(mol)\n",
        "            atoms = mol.GetNumAtoms()\n",
        "            rings = mol.GetRingInfo().NumRings()\n",
        "            # Add complexity bias\n",
        "            boiling_points[i] += weight * 0.2 + atoms * 2 + rings * 15\n",
        "            \n",
        "    # Create the dataset\n",
        "    df = pd.DataFrame({\n",
        "        'SMILES': sample_smiles,\n",
        "        'BoilingPoint': boiling_points\n",
        "    })\n",
        "    print(f\"Sample dataset created with shape: {df.shape}\")\n",
        "\n",
        "# Display the first few rows of the dataset\n",
        "df.head()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 2. Calculate Morgan Fingerprints"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Function to calculate fingerprints\n",
        "def get_morgan_fingerprint(smiles, radius=2, nBits=1024):\n",
        "    mol = Chem.MolFromSmiles(smiles)\n",
        "    if mol is None:\n",
        "        return None\n",
        "    fingerprint = AllChem.GetMorganFingerprintAsBitVect(mol, radius, nBits=nBits)\n",
        "    return np.array(fingerprint)\n",
        "\n",
        "# Calculate fingerprints for all molecules\n",
        "fingerprints = []\n",
        "valid_indices = []\n",
        "\n",
        "for i, smiles in enumerate(df['SMILES']):\n",
        "    fp = get_morgan_fingerprint(smiles)\n",
        "    if fp is not None:\n",
        "        fingerprints.append(fp)\n",
        "        valid_indices.append(i)\n",
        "\n",
        "# Keep only valid molecules\n",
        "X = np.array(fingerprints)\n",
        "df_valid = df.iloc[valid_indices].reset_index(drop=True)\n",
        "y = df_valid['BoilingPoint'].values\n",
        "\n",
        "# Display shapes\n",
        "print(f\"Features shape: {X.shape}\")\n",
        "print(f\"Target shape: {y.shape}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 3. Data Preparation"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Split the data\n",
        "X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25, random_state=42)\n",
        "\n",
        "# Scale the target values\n",
        "scaler = StandardScaler()\n",
        "y_train_scaled = scaler.fit_transform(y_train.reshape(-1, 1)).flatten()\n",
        "y_test_scaled = scaler.transform(y_test.reshape(-1, 1)).flatten()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 4. Neural Network Model"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Build a neural network model\n",
        "def build_model(input_dim):\n",
        "    model = keras.Sequential([\n",
        "        layers.Dense(512, activation='relu', input_shape=(input_dim,)),\n",
        "        layers.Dropout(0.2),\n",
        "        layers.Dense(256, activation='relu'),\n",
        "        layers.Dropout(0.2),\n",
        "        layers.Dense(128, activation='relu'),\n",
        "        layers.Dense(64, activation='relu'),\n",
        "        layers.Dense(1)\n",
        "    ])\n",
        "    \n",
        "    model.compile(\n",
        "        optimizer='adam',\n",
        "        loss='mse',\n",
        "        metrics=['mae']\n",
        "    )\n",
        "    \n",
        "    return model\n",
        "\n",
        "# Create and fit the model\n",
        "model = build_model(X_train.shape[1])\n",
        "history = model.fit(\n",
        "    X_train, y_train_scaled,\n",
        "    epochs=50,\n",
        "    batch_size=8,\n",
        "    validation_split=0.2,\n",
        "    verbose=1\n",
        ")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 5. Visualize Training History"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Plot training history\n",
        "plt.figure(figsize=(12, 4))\n",
        "\n",
        "plt.subplot(1, 2, 1)\n",
        "plt.plot(history.history['loss'])\n",
        "plt.plot(history.history['val_loss'])\n",
        "plt.title('Model Loss')\n",
        "plt.ylabel('Loss')\n",
        "plt.xlabel('Epoch')\n",
        "plt.legend(['Train', 'Validation'], loc='upper right')\n",
        "\n",
        "plt.subplot(1, 2, 2)\n",
        "plt.plot(history.history['mae'])\n",
        "plt.plot(history.history['val_mae'])\n",
        "plt.title('Model MAE')\n",
        "plt.ylabel('Mean Absolute Error')\n",
        "plt.xlabel('Epoch')\n",
        "plt.legend(['Train', 'Validation'], loc='upper right')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 6. Model Evaluation"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Evaluate the model\n",
        "y_pred_scaled = model.predict(X_test).flatten()\n",
        "y_pred = scaler.inverse_transform(y_pred_scaled.reshape(-1, 1)).flatten()\n",
        "\n",
        "# Calculate metrics\n",
        "mse = mean_squared_error(y_test, y_pred)\n",
        "rmse = np.sqrt(mse)\n",
        "r2 = r2_score(y_test, y_pred)\n",
        "\n",
        "print(f\"Mean Squared Error: {mse:.2f}\")\n",
        "print(f\"Root Mean Squared Error: {rmse:.2f}\")\n",
        "print(f\"R² Score: {r2:.4f}\")"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 7. Visualization of Results"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Scatter plot of actual vs predicted values\n",
        "plt.figure(figsize=(10, 8))\n",
        "\n",
        "# Calculate optimal fit line\n",
        "z = np.polyfit(y_test, y_pred, 1)\n",
        "p = np.poly1d(z)\n",
        "\n",
        "plt.scatter(y_test, y_pred, alpha=0.7, s=80)\n",
        "plt.plot(y_test, p(y_test), \"r--\", linewidth=2)\n",
        "plt.plot([min(y_test), max(y_test)], [min(y_test), max(y_test)], 'k--', linewidth=1.5)\n",
        "\n",
        "plt.title('Neural Network Model: Actual vs Predicted Boiling Points', fontsize=16)\n",
        "plt.xlabel('Actual Boiling Point (°C)', fontsize=14)\n",
        "plt.ylabel('Predicted Boiling Point (°C)', fontsize=14)\n",
        "plt.grid(True, alpha=0.3)\n",
        "\n",
        "# Add statistics to plot\n",
        "stats_text = f\"RMSE: {rmse:.2f}°C\\nR²: {r2:.4f}\"\n",
        "plt.annotate(stats_text, xy=(0.05, 0.95), xycoords='axes fraction', \n",
        "            bbox=dict(boxstyle=\"round,pad=0.3\", fc=\"white\", ec=\"gray\", alpha=0.8), \n",
        "            fontsize=12, ha='left', va='top')\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 8. Error Analysis"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Calculate errors\n",
        "errors = y_test - y_pred\n",
        "abs_errors = np.abs(errors)\n",
        "\n",
        "# Create results dataframe\n",
        "results_df = pd.DataFrame({\n",
        "    'SMILES': df_valid.iloc[y_test.index]['SMILES'].values,\n",
        "    'Actual': y_test,\n",
        "    'Predicted': y_pred,\n",
        "    'Error': errors,\n",
        "    'Abs_Error': abs_errors\n",
        "})\n",
        "\n",
        "# Plot error distribution\n",
        "plt.figure(figsize=(12, 5))\n",
        "\n",
        "plt.subplot(1, 2, 1)\n",
        "sns.histplot(errors, kde=True, bins=15)\n",
        "plt.axvline(x=0, color='r', linestyle='--')\n",
        "plt.title('Distribution of Prediction Errors', fontsize=14)\n",
        "plt.xlabel('Error (°C)', fontsize=12)\n",
        "plt.ylabel('Frequency', fontsize=12)\n",
        "\n",
        "plt.subplot(1, 2, 2)\n",
        "sns.scatterplot(x='Predicted', y='Error', data=results_df, alpha=0.7)\n",
        "plt.axhline(y=0, color='r', linestyle='--')\n",
        "plt.title('Residual Plot', fontsize=14)\n",
        "plt.xlabel('Predicted Boiling Point (°C)', fontsize=12)\n",
        "plt.ylabel('Error (°C)', fontsize=12)\n",
        "\n",
        "plt.tight_layout()\n",
        "plt.show()"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 9. Visualize Molecules with Largest Errors"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Function to display molecules\n",
        "def display_molecules_grid(smiles_list, labels=None, n_cols=4, mol_size=(300, 300)):\n",
        "    mols = [Chem.MolFromSmiles(s) for s in smiles_list]\n",
        "    mols = [m for m in mols if m is not None]\n",
        "    if len(mols) == 0:\n",
        "        return None\n",
        "    \n",
        "    from rdkit.Chem import Draw\n",
        "    return Draw.MolsToGridImage(mols, molsPerRow=n_cols, subImgSize=mol_size, legends=labels if labels else [])\n",
        "\n",
        "# Get molecules with largest absolute errors\n",
        "largest_errors = results_df.nlargest(8, 'Abs_Error')\n",
        "\n",
        "# Display molecules with largest errors\n",
        "error_labels = [f\"Actual: {row['Actual']:.1f}, Pred: {row['Predicted']:.1f}, Error: {row['Error']:.1f}\" \n",
        "               for _, row in largest_errors.iterrows()]\n",
        "\n",
        "print(\"Molecules with Largest Prediction Errors:\")\n",
        "img = display_molecules_grid(largest_errors['SMILES'].tolist(), error_labels, n_cols=4)\n",
        "display(img)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": ["## 10. Interactive Model Prediction"]
    },
    {
      "cell_type": "code",
      "execution_count": null,
      "metadata": {},
      "outputs": [],
      "source": [
        "# Function to predict boiling point for a new molecule\n",
        "def predict_boiling_point(smiles):\n",
        "    mol = Chem.MolFromSmiles(smiles)\n",
        "    if mol is None:\n",
        "        return \"Invalid SMILES string\"\n",
        "    \n",
        "    # Calculate fingerprint\n",
        "    fp = get_morgan_fingerprint(smiles)\n",
        "    if fp is None:\n",
        "        return \"Could not calculate fingerprint\"\n",
        "    \n",
        "    # Make prediction\n",
        "    fp = fp.reshape(1, -1)\n",
        "    pred_scaled = model.predict(fp).flatten()[0]\n",
        "    pred = scaler.inverse_transform([[pred_scaled]])[0][0]\n",
        "    \n",
        "    # Display the molecule\n",
        "    from rdkit.Chem import Draw\n",
        "    img = Draw.MolToImage(mol, size=(400, 300))\n",
        "    \n",
        "    # Also calculate some basic descriptors\n",
        "    mol_wt = Descriptors.MolWt(mol)\n",
        "    logp = Descriptors.MolLogP(mol)\n",
        "    rot_bonds = Descriptors.NumRotatableBonds(mol)\n",
        "    \n",
        "    print(f\"Predicted Boiling Point: {pred:.2f}°C\")\n",
        "    print(f\"Molecular Weight: {mol_wt:.2f}\")\n",
        "    print(f\"LogP: {logp:.2f}\")\n",
        "    print(f\"Rotatable Bonds: {rot_bonds}\")\n",
        "    \n",
        "    display(img)\n",
        "    \n",
        "    return pred\n",
        "\n",
        "# Test with a few examples\n",
        "test_molecules = [\n",
        "    'CCO',  # Ethanol\n",
        "    'CCCC',  # Butane\n",
        "    'c1ccccc1',  # Benzene\n",
        "    'CCCCO'  # 1-Butanol\n",
        "]\n",
        "\n",
        "for smiles in test_molecules:\n",
        "    print(f\"\\nPrediction for {smiles}:\")\n",
        "    predict_boiling_point(smiles)"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## 11. Conclusion\n",
        "\n",
        "This notebook demonstrates a neural network model for predicting molecular boiling points based on Morgan fingerprints. We've shown:\n",
        "\n",
        "1. How to prepare molecular fingerprints as input features\n",
        "2. How to build and train a neural network model\n",
        "3. Various ways to visualize and evaluate model performance\n",
        "4. Interactive prediction for new molecules\n",
        "\n",
        "The model can be extended to predict other molecular properties by changing the target variable."
      ]
    }
  ],
  "metadata": {
    "kernelspec": {
      "display_name": "Python 3",
      "language": "python",
      "name": "python3"
    },
    "language_info": {
      "codemirror_mode": {
        "name": "ipython",
        "version": 3
      },
      "file_extension": ".py",
      "mimetype": "text/x-python",
      "name": "python",
      "nbconvert_exporter": "python",
      "pygments_lexer": "ipython3",
      "version": "3.8.10"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 4
}
